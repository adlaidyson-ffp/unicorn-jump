<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unicorn Jump: Endless Runner Game</title>
    
    <meta name="title" content="Unicorn Jump: Endless Runner">
    <meta name="description" content="A magical, endless runner game featuring a jumping unicorn! Playable on desktop and mobile. With slow, medium, fast and progressive speed modes!">
    <meta name="keywords" content="unicorn jump, retro game, endless runner, arcade, double jump, HTML5 game">
    
    <link rel="icon" type="image/png" href="https://cdn.fusedframe.co.uk/unicorn-jump/logos/Unicorn-Jump-Favicon-(Transparent).png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-purple: #2c1a3b;
            --dark-pink: #4c1d2e;
            --light-pink: #ffc0cb;
            --white: #fff;
            --text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        /* Basic styles for the page */
        body {
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center;
            height: 100vh;
            overflow: hidden; 
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(135deg, var(--dark-pink), var(--dark-purple));
            color: var(--white);
            text-shadow: var(--text-shadow);
        }

        /* Styles for the Game Title Banner */
        .game-title-banner {
            width: 100%;
            max-width: 350px;
            margin-bottom: 15px;
            text-align: center;
            flex-shrink: 0;
        }

        .game-title-banner img {
            width: 90%;
            height: auto;
            opacity: 0.95;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.4));
        }

        /* Container for the game canvas and UI elements */
        .game-container {
            position: relative;
            width: 95vw;
            max-width: 800px;
            /* Using aspect-ratio to maintain a consistent shape */
            aspect-ratio: 16 / 9; 
            /* Limit height on very tall, thin screens */
            max-height: calc(100vh - 160px); 
            border: 4px solid var(--white);
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), inset 0 0 15px rgba(255, 255, 255, 0.3);
            overflow: hidden;
            background: linear-gradient(135deg, #ffc0cb, #d3a2e2);
            transition: transform 0.1s ease-out; /* For screen shake effect */
        }

        /* The main game canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Overlay for messages like "Game Over" or "Tap to Start" */
        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            z-index: 10;
            padding: 10px;
            box-sizing: border-box;
            opacity: 1;
            transition: opacity 0.2s ease; /* Faster transition */
        }

        .message-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .message-overlay h1 {
            /* Using clamp for responsive font sizes */
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            margin-bottom: 0.5em;
        }

        .message-overlay p {
            font-size: clamp(0.8rem, 3vw, 1.2rem);
        }

        .message-overlay .instructions {
            font-size: clamp(0.7rem, 2.5vw, 1rem);
            margin-top: 1em;
            max-width: 80%;
            line-height: 1.5;
        }

        /* Styling for score and high score displays */
        .score-display, .high-score-display {
            position: absolute;
            top: 20px;
            font-size: clamp(1rem, 4vw, 1.5rem);
            -webkit-text-stroke: 1px var(--dark-purple);
        }
        .score-display {
            right: 20px;
        }
        .high-score-display {
            left: 20px;
            font-size: clamp(0.8rem, 3vw, 1.2rem);
        }
        
        /* Styling for the pause button */
        .pause-button {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
            z-index: 11;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: clamp(35px, 8vw, 45px);
            height: clamp(35px, 8vw, 45px);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1rem, 4vw, 1.3rem);
            line-height: 1;
            color: var(--white);
            text-shadow: 1px 1px 2px var(--dark-purple);
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .pause-button:active {
            background-color: rgba(255, 255, 255, 0.5);
            transform: translateX(-50%) scale(0.95);
        }

        /* Styles for the difficulty selector */
        .difficulty-selector {
            margin-top: 1.5em;
            display: flex;
            flex-wrap: wrap; /* Allows buttons to wrap on smaller screens */
            justify-content: center;
            align-items: center;
            gap: clamp(8px, 2vw, 15px);
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .difficulty-btn {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(0.6rem, 2.5vw, 0.8rem);
            padding: 10px 15px;
            color: var(--white);
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            text-shadow: 1px 1px 2px var(--dark-purple);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .difficulty-btn svg {
            width: clamp(16px, 4vw, 20px);
            height: clamp(16px, 4vw, 20px);
            fill: currentColor;
        }

        .difficulty-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .difficulty-btn.selected {
            background-color: var(--light-pink);
            color: var(--dark-purple);
            border-color: var(--white);
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-shadow: none;
        }
        
        .hidden {
            display: none !important;
        }

        /* Footer styling */
        footer {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px; /* Reduced gap */
            flex-shrink: 0;
        }

        footer img {
            width: 180px;
            opacity: 0.8;
            margin-top: 5px; /* Added margin for spacing */
        }

        footer p {
            margin: 0;
            font-size: 0.7rem;
        }

        .github-container {
            margin-top: 5px;
        }

        /* Mobile scaling for portrait mode */
        @media (orientation: portrait) {
            .game-container {
                /* Make the game taller on portrait screens */
                aspect-ratio: 9 / 12;
                width: 90vw;
                max-height: calc(100vh - 200px); 
            }
             .difficulty-btn {
                font-size: clamp(0.7rem, 3vw, 1rem);
                padding: 12px 18px;
            }
            .message-overlay h1 {
                font-size: clamp(2rem, 8vw, 3.5rem);
            }
             .message-overlay p {
                font-size: clamp(1rem, 4vw, 1.5rem);
            }
        }

    </style>
</head>
<body>

    <header class="game-title-banner">
        <img src="https://cdn.fusedframe.co.uk/unicorn-jump/logos/Unicorn-Jump-Banner-Logo-(Transparent).png" alt="Unicorn Jump Logo">
    </header>

    <main id="gameContainer" class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="pauseButton" class="pause-button hidden">||</div>
        <div id="messageOverlay" class="message-overlay">
            <h1 id="messageTitle">Unicorn Jump</h1>
            <p id="messageText">Press Space or Tap to Start</p>
            <p id="instructionsText" class="instructions">Tap once to jump, and tap again in mid-air for a double jump! You must jump over ALL obstacles.</p>
            <div id="difficultySelector" class="difficulty-selector">
                <button class="difficulty-btn" data-mode="slow">Slow</button>
                <button class="difficulty-btn" data-mode="medium">Medium</button>
                <button class="difficulty-btn" data-mode="fast">Fast</button>
                <button class="difficulty-btn" data-mode="progressive">Progressive</button>
            </div>
        </div>
        <div id="highScoreDisplay" class="high-score-display">HI 0</div>
        <div id="scoreDisplay" class="score-display">0</div>
    </main>

    <footer>
        <p>Made for Leilani</p>
        <div class="github-container">
            <a href="http://adffp.uk/uni-jump-github" target="_blank" rel="noopener noreferrer" class="difficulty-btn github-btn">
                <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
                View on GitHub
            </a>
        </div>
         <img src="https://cdn.fusedframe.co.uk/main-logos/png/Banner%20Logo%20(No%20Circle)%20Light%20(Transparent).png" alt="Banner Logo">
    </footer>

<script>
    // Self-invoking function to encapsulate game logic and avoid polluting global scope
    (function() {
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const instructionsText = document.getElementById('instructionsText');
        const pauseButton = document.getElementById('pauseButton');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');


        // --- Core Game State ---
        let isPlaying = false;
        let isPaused = false;
        let gameOver = false;
        let isGameOverTransitioning = false; // Prevents input during game over animation
        let score = 0;
        let highScore = localStorage.getItem('unicornHighScore') || 0;
        let lastTime = 0;
        let scaleFactor = 1;
        let gameSpeedMode = localStorage.getItem('unicornSpeedMode') || 'progressive';

        // --- Game Entities ---
        let unicorn = {};
        let obstacles = [];
        let particles = [];
        let stars = [];
        
        // --- Time-based Spawning ---
        let timeToNextObstacle = 0;

        // --- Constants ---
        const REFERENCE_HEIGHT = 450;
        const GROUND_HEIGHT_RATIO = 0.85;
        const GRAVITY = 1800; // Reduced for a floatier jump
        const JUMP_STRENGTH = -850; // Increased for more height
        const BASE_GAME_SPEED_PPS = 0.25;
        const GAME_SPEED_INCREASE_FACTOR = 0.0002;
        const INITIAL_OBSTACLE_DELAY = 2.5;
        const MAX_STARS = 50;
        const MAX_PARTICLES = 100;
        const PARTICLE_COUNT_ON_JUMP = 5;
        const COLLISION_PADDING = 0.25; // More forgiving hitboxes

        // Difficulty Speed Multipliers
        const SLOW_SPEED_MULTIPLIER = 0.9; // Adjusted for better playability
        const MEDIUM_SPEED_MULTIPLIER = 1.25;
        const FAST_SPEED_MULTIPLIER = 1.75;


        // Unicorn sprite
        const unicornImage = new Image();
        let isImageLoaded = false;
        unicornImage.onload = () => {
            isImageLoaded = true;
            draw(0); 
        };
        unicornImage.src = 'https://cdn.fusedframe.co.uk/unicorn-jump/sprite/Unicorn-Sprite.png';

        function resizeAndScale() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            scaleFactor = canvas.height / REFERENCE_HEIGHT;
            const unicornBaseSize = 85;
            unicorn.width = unicornBaseSize * scaleFactor;
            unicorn.height = unicornBaseSize * scaleFactor;
            unicorn.x = canvas.width * 0.1;
            if (unicorn.isGrounded) {
                unicorn.y = canvas.height * GROUND_HEIGHT_RATIO - unicorn.height;
            }
            if (stars.length === 0) {
                createStars();
            }
            draw(0);
        }

        function resetGame() {
            score = 0;
            obstacles = [];
            particles = [];
            timeToNextObstacle = INITIAL_OBSTACLE_DELAY;
            gameOver = false;
            isPaused = false;
            
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            unicorn = {
                x: canvas.width * 0.1,
                y: groundY - (85 * scaleFactor),
                width: 85 * scaleFactor,
                height: 85 * scaleFactor,
                velocityY: 0,
                jumpsLeft: 2,
                isGrounded: true,
            };
            
            scoreDisplay.textContent = 0;
            updateHighScoreDisplay();
            
            messageTitle.textContent = 'Unicorn Jump';
            messageText.textContent = 'Press Space or Tap to Start';
            instructionsText.style.display = 'block';
        }
        
        function startGame() {
            if (isPlaying || isGameOverTransitioning) return;
            resetGame();
            isPlaying = true;
            messageOverlay.classList.add('hidden');
            pauseButton.classList.remove('hidden');
            lastTime = performance.now();
            jump();
            requestAnimationFrame(gameLoop);
        }

        function triggerGameOver() {
            if (gameOver) return;
            gameOver = true;
            isPlaying = false;
            isGameOverTransitioning = true;
            pauseButton.classList.add('hidden');
            
            let shakeTime = 0.3;
            const shakeInterval = setInterval(() => {
                const x = (Math.random() - 0.5) * 10;
                const y = (Math.random() - 0.5) * 10;
                gameContainer.style.transform = `translate(${x}px, ${y}px)`;
                shakeTime -= 0.05;
                if (shakeTime <= 0) {
                    clearInterval(shakeInterval);
                    gameContainer.style.transform = 'translate(0, 0)';
                    
                    const finalScore = Math.floor(score);
                    if (finalScore > highScore) {
                        highScore = finalScore;
                        localStorage.setItem('unicornHighScore', highScore);
                        updateHighScoreDisplay();
                    }
                    
                    messageTitle.textContent = 'Game Over';
                    messageText.textContent = 'Press Space or Tap to Restart';
                    instructionsText.style.display = 'none';
                    messageOverlay.classList.remove('hidden');
                    isGameOverTransitioning = false; // Allow restarting now
                }
            }, 50);
        }

        function togglePause() {
            if (gameOver || !isPlaying) return;
            isPaused = !isPaused;
            if (isPaused) {
                messageTitle.textContent = 'Paused';
                messageText.textContent = 'Press P or Tap Button to Resume';
                instructionsText.style.display = 'none';
                messageOverlay.classList.remove('hidden');
            } else {
                messageOverlay.classList.add('hidden');
                // To prevent a time jump, reset lastTime when unpausing
                lastTime = performance.now(); 
                requestAnimationFrame(gameLoop);
            }
        }

        function drawStars(deltaTime) {
            const parallaxSpeed = getCurrentGameSpeed() * 0.1;
            ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
            for (const star of stars) {
                star.x -= parallaxSpeed * deltaTime;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * (canvas.height * GROUND_HEIGHT_RATIO);
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawGround() {
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            const gradient = ctx.createLinearGradient(0, groundY - 5, 0, groundY + 5);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#f0f0f0');
            gradient.addColorStop(1, '#ffffff');
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
        }

        function drawUnicorn() {
            if (!isImageLoaded) return;
            ctx.save();
            const unicornCenterX = unicorn.x + unicorn.width / 2;
            const unicornCenterY = unicorn.y + unicorn.height / 2;
            ctx.translate(unicornCenterX, unicornCenterY);

            if (unicorn.isGrounded) {
                // Gentle bobbing animation when on the ground
                const bobbleRotation = Math.sin(performance.now() * 0.005) * 0.08;
                ctx.rotate(bobbleRotation);
            } else {
                // Dynamic rotation based on vertical velocity for a nice arc effect
                const maxRotation = 0.5; // Max rotation in radians (about 30 degrees)
                let dynamicRotation = unicorn.velocityY * 0.0003; 
                dynamicRotation = Math.max(-maxRotation, Math.min(maxRotation, dynamicRotation));
                ctx.rotate(dynamicRotation);
            }

            ctx.drawImage(unicornImage, -unicorn.width / 2, -unicorn.height / 2, unicorn.width, unicorn.height);
            ctx.restore();
        }
        
        function drawObstacles() {
            for (const obstacle of obstacles) {
                if (obstacle.type === 'rainbow') {
                    const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082'];
                    const radius = obstacle.width / 2;
                    const yPos = obstacle.y + radius;
                    for (let i = 0; i < colors.length; i++) {
                        ctx.beginPath();
                        ctx.arc(obstacle.x + radius, yPos, radius - i * (4 * scaleFactor), Math.PI, 0, false);
                        ctx.strokeStyle = colors[i];
                        ctx.lineWidth = 4 * scaleFactor;
                        ctx.stroke();
                    }
                } else { // Cloud
                    ctx.fillStyle = '#f0f8ff';
                    ctx.beginPath();
                    const s = scaleFactor;
                    ctx.arc(obstacle.x + 20*s, obstacle.y + 20*s, 20*s, Math.PI * 0.5, Math.PI * 1.5);
                    ctx.arc(obstacle.x + 40*s, obstacle.y + 10*s, 25*s, Math.PI * 1, Math.PI * 2);
                    ctx.arc(obstacle.x + 65*s, obstacle.y + 20*s, 20*s, Math.PI * 1.5, Math.PI * 0.5);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function updateAndDrawParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.vy += (GRAVITY * 0.5) * deltaTime;
                p.lifespan -= deltaTime;
                if (p.lifespan <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.lifespan / p.initialLifespan;
                    ctx.fillStyle = '#f0e456';
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        function draw(deltaTime) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(deltaTime);
            drawGround();
            drawObstacles();
            drawUnicorn();
        }

        function updateUnicorn(deltaTime) {
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            unicorn.velocityY += (GRAVITY * scaleFactor) * deltaTime;
            unicorn.y += unicorn.velocityY * deltaTime;
            if (unicorn.y + unicorn.height >= groundY) {
                unicorn.y = groundY - unicorn.height;
                unicorn.velocityY = 0;
                if (!unicorn.isGrounded) {
                    unicorn.jumpsLeft = 2;
                    unicorn.isGrounded = true;
                }
            }
        }
        
        function getCurrentGameSpeed() {
            const baseSpeed = canvas.width * BASE_GAME_SPEED_PPS;
            switch(gameSpeedMode) {
                case 'slow': return baseSpeed * SLOW_SPEED_MULTIPLIER;
                case 'medium': return baseSpeed * MEDIUM_SPEED_MULTIPLIER;
                case 'fast': return baseSpeed * FAST_SPEED_MULTIPLIER;
                case 'progressive':
                default:
                    return baseSpeed + (score * GAME_SPEED_INCREASE_FACTOR * canvas.width);
            }
        }

        function updateObstacles(deltaTime) {
            const currentGameSpeed = getCurrentGameSpeed();
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= currentGameSpeed * deltaTime;
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }

        function updateScore(deltaTime) {
            score += deltaTime * 10;
            scoreDisplay.textContent = Math.floor(score);
        }

        function checkCollisions() {
            const paddingWidth = unicorn.width * COLLISION_PADDING;
            const paddingHeight = unicorn.height * COLLISION_PADDING;
            for (const obstacle of obstacles) {
                let hitbox = { ...obstacle };
                if (hitbox.type === 'rainbow') {
                    hitbox.height *= 0.5;
                }
                if (unicorn.x < hitbox.x + hitbox.width - paddingWidth &&
                    unicorn.x + unicorn.width > hitbox.x + paddingWidth &&
                    unicorn.y < hitbox.y + hitbox.height - paddingHeight &&
                    unicorn.y + unicorn.height > hitbox.y + paddingHeight) {
                    return true;
                }
            }
            return false;
        }

        function checkPassUnder() {
            for (const obstacle of obstacles) {
                if (obstacle.isHigh) {
                    const unicornRight = unicorn.x + unicorn.width;
                    const obstacleLeft = obstacle.x;
                    const obstacleRight = obstacle.x + obstacle.width;

                    // Check if the unicorn is horizontally within the bounds of the high cloud
                    if (unicornRight > obstacleLeft && unicorn.x < obstacleRight) {
                        // If horizontally aligned, check if the unicorn is on the ground
                        if (unicorn.isGrounded) {
                            return true; // Game over for being on the ground under a high cloud
                        }
                    }
                }
            }
            return false;
        }

        function gameLoop(currentTime) {
            if (!isPlaying || isPaused) return;

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateUnicorn(deltaTime);
            updateObstacles(deltaTime);
            updateScore(deltaTime);
            
            timeToNextObstacle -= deltaTime;
            if (timeToNextObstacle <= 0) {
                spawnObstacle();
                let spawnDelay;
                if (gameSpeedMode === 'progressive') {
                    const speedProgress = Math.min(1, (score / 500));
                    spawnDelay = INITIAL_OBSTACLE_DELAY - (1.2 * speedProgress);
                } else {
                    switch(gameSpeedMode) {
                        case 'slow': spawnDelay = INITIAL_OBSTACLE_DELAY / SLOW_SPEED_MULTIPLIER; break;
                        case 'medium': spawnDelay = INITIAL_OBSTACLE_DELAY / MEDIUM_SPEED_MULTIPLIER; break;
                        case 'fast': spawnDelay = INITIAL_OBSTACLE_DELAY / FAST_SPEED_MULTIPLIER; break;
                        default: spawnDelay = INITIAL_OBSTACLE_DELAY;
                    }
                }
                timeToNextObstacle = spawnDelay * (0.8 + Math.random() * 0.4);
            }

            draw(deltaTime);
            updateAndDrawParticles(deltaTime);

            if (checkCollisions() || checkPassUnder()) {
                triggerGameOver();
                return;
            }
            requestAnimationFrame(gameLoop);
        }
        
        function createStars() {
            stars = [];
            for (let i = 0; i < MAX_STARS; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * GROUND_HEIGHT_RATIO),
                    size: Math.random() * 1.5 + 0.5
                });
            }
        }

        function jump() {
            if (unicorn.jumpsLeft > 0) {
                unicorn.velocityY = JUMP_STRENGTH * scaleFactor;
                unicorn.jumpsLeft--;
                unicorn.isGrounded = false;
                createJumpParticles();
            }
        }

        function createJumpParticles() {
            if (particles.length > MAX_PARTICLES) return;
            for (let i = 0; i < PARTICLE_COUNT_ON_JUMP; i++) {
                const angle = Math.random() * Math.PI - Math.PI;
                const speed = (Math.random() * 100 + 50) * scaleFactor;
                const lifespan = Math.random() * 0.5 + 0.3;
                particles.push({
                    x: unicorn.x + unicorn.width / 2,
                    y: unicorn.y + unicorn.height,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: (Math.random() * 2 + 2) * scaleFactor,
                    lifespan: lifespan,
                    initialLifespan: lifespan
                });
            }
        }

        function spawnObstacle() {
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            const type = Math.random() > 0.4 ? 'rainbow' : 'cloud';
            
            const baseWidth = 80 * scaleFactor;
            let obstacle;

            if (type === 'rainbow') {
                const height = 50 * scaleFactor;
                obstacle = { x: canvas.width, y: groundY - height, width: baseWidth, height, type };
            } else { // Cloud
                const height = 40 * scaleFactor;
                const isHighCloud = score > 50 && Math.random() > 0.5;
                const yPos = isHighCloud ? groundY - (120 * scaleFactor) : groundY - height;
                obstacle = { x: canvas.width, y: yPos, width: baseWidth, height, type, isHigh: isHighCloud };
            }
            obstacles.push(obstacle);
        }
        
        function updateHighScoreDisplay() {
            highScoreDisplay.textContent = `HI ${highScore}`;
        }
        
        function handleInput(e) {
            e.preventDefault();
            if (isGameOverTransitioning) return; // Prevent actions during game over
            
            if (!isPlaying) { // Handles starting and restarting
                startGame();
            } else if (!isPaused) { // Handles jumping only if playing and not paused
                jump();
            }
        }

        // --- Event Listeners ---

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
            if (e.code === 'KeyP') togglePause();
        });
        
        pauseButton.addEventListener('click', togglePause);
        
        gameContainer.addEventListener('touchend', (e) => {
            if (e.target.closest('.difficulty-btn') || e.target === pauseButton) return;
            handleInput(e);
        }, { passive: false });
        
        gameContainer.addEventListener('mousedown', (e) => {
            if (e.target.closest('.difficulty-btn') || e.target === pauseButton) return;
            handleInput(e);
        }, { passive: false });
        
        difficultyButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                if(button.classList.contains('github-btn')) return;
                e.stopPropagation(); // prevent game from starting when clicking difficulty
                gameSpeedMode = button.dataset.mode;
                localStorage.setItem('unicornSpeedMode', gameSpeedMode);
                document.querySelectorAll('.difficulty-btn[data-mode]').forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
            });
        });

        new ResizeObserver(resizeAndScale).observe(gameContainer);
        
        // --- Initial Setup ---
        updateHighScoreDisplay();

        // Set the visual state of the difficulty buttons on load
        document.querySelectorAll('.difficulty-btn[data-mode]').forEach(btn => {
            if(btn.dataset.mode === gameSpeedMode) {
                btn.classList.add('selected');
            } else {
                btn.classList.remove('selected');
            }
        });
        
        resetGame();
        resizeAndScale();
    })();
</script>
</body>
</html>